""" Allows a function to execute as if locals are a context
"""
import dis, struct, new

##############################################################################
# Implementation Notes
#    This works by shifting all local variable names into the global variable
# names list and then replacing all STORE_*, LOAD_*, and DELETE_* operations
# with the *_NAME versions.
#
#    We might be able to refine somewhat by keeping non-arg locals as *_FAST
#
#    An alternative approach would be to add bytecodes which store the
# arguments from a const list, but although this might end up being faster,
# it requires more complex manipulation of the bytecode (adding instructions
# may mess with jump locations) as well as creating a new code object on every
# function call so that the correct const values can be loaded in.
#
##############################################################################

def parse_bytecode(bytes):
    """ Take a bytecode string and generate (operation, argument) tuples.
    """
    i = 0
    while i < len(bytes):
        op = ord(bytes[i])
        i += 1
        if op >= dis.HAVE_ARGUMENT:
            arg = struct.unpack("<h", bytes[i:i+2])[0]
            i += 2
        else:
            arg = None
        yield dis.opname[op], arg

def compile_bytecode(ops):
    """ Take (operation, argument) tuples and return a bytecode string.
    """
    return ''.join(chr(dis.opmap[op])+(struct.pack('<h', arg)
                                        if arg != None else '')
                    for op, arg in ops)

def patch_load_and_store(ops, argcount, nglobals):
    """ Generator which replaces *_FAST and *_GLOBAL ops with *_NAME ops
    """
    for op, arg in ops:
        if op  == 'LOAD_FAST':
            op = 'LOAD_NAME'
            arg += nglobals
        elif op == 'STORE_FAST':
            op = 'STORE_NAME'
            arg += nglobals
        elif op == 'DELETE_FAST':
            op = 'DELETE_NAME'
            arg += nglobals
        elif op  == 'LOAD_GLOBAL':
            op = 'LOAD_NAME'
        elif op == 'STORE_GLOBAL':
            op = 'STORE_NAME'
        elif op == 'DELETE_GLOBAL':
            op = 'DELETE_NAME'
        elif op in dis.hasname:
            arg += argcount
        yield op, arg

def args_to_locals(co):
    """ Turn arguments of a function into local variables in a code object
    """
    nglobals = len(co.co_names)
    co_code = compile_bytecode(patch_load_and_store(parse_bytecode(co.co_code),
                                   co.co_argcount, nglobals))
    print co.co_names, co.co_varnames
    return new.code(0, co.co_nlocals+len(co.co_varnames), co.co_stacksize, co.co_flags & ~15,
        co_code, co.co_consts, co.co_names+co.co_varnames, (),
        co.co_filename, co.co_name, co.co_firstlineno, co.co_lnotab)

def context_function(f, context_factory):
    """ Allows a function to execute as if locals are a context
    
    This decorator modifies a function so that it uses contexts generated by
    a context_factory in place of the usual local dictionary.  In most cases
    the context_factory function should return a fresh context on each call.
    
    Potential uses include:
      * over-riding internal globals by pre-inserting values into the local
        namespace (eg. replacing math with numpy in the function's namespace
        so that a function can be converted to use with arrays).
      * internal unit conversion
      * introspection of function operation
    
    This decorator works by re-writing the function's bytecode, so it will
    not work for functions coming from C extension modules.
    
    Parameters
        f : function
            the function to be decorated
        context_factory : callable
            a callable that returns a context to be used as the function's
            local namespace
    
    Returns
        a function that can be used in place of f
        
    Examples
        Over-writing a global in a function using a pre-filled local context
        
        >>> import math
        >>> def f(x):
        ...     return 2*math.sin(x) + math.cos(x)
        >>> import numpy
        >>> def numpy_math_context():
        ...     return {'math': numpy}
        >>> f = context_function(f, numpy_math_context)
        >>> f(numpy.array([0, 0.5, 1])*numpy.pi)
        array([1.0, 2.1213203435596424, 2])
        
        Recursively apply context_function to a context: this example will
        recursively apply the numpy_math_context from the previous example.
        
        >>> from enthought.contexts.adapter.context_function_adapter import ContextFunctionAdapter
        >>> from enthought.contexts.api import AdaptedDataContext
        >>> def recursive_context_factory(context_factory):
        ...     def new_context_factory():
        ...         context = AdaptedDataContext(subcontext=context_factory())
        ...         context.push_adapter(ContextFunctionAdapter(context_factory=new_context_factory))
        ...         return context
        ...     return new_context_factory
        >>> recursive_numpy_math_context = recursive_context_factory(numpy_math_context)
        >>> def recursive_numpy_math(f):
        ...      return context_function(f, recursive_numpy_math_context)
        
    """
    
    # values that we may as well pre-calculate
    print dis.dis(f)
    code = args_to_locals(f.func_code)
    print dis.dis(code)
    
    def new_f(*args, **kwargs):
        loc = context_factory()
        arg_len = f.func_code.co_argcount
        named_args = f.func_code.co_varnames[:arg_len]
        if arg_len < len(args):
            if f.func_code.co_flags & 4:
                loc.update(dict(zip(named_args, args[:arg_len])))
                loc[f.func_code.co_varnames[arg_len]] = args[arg_len:]
                if f.func_code.co_flags & 8:
                    loc[f.func_code.co_varnames[arg_len+1]] = kwargs                    
            else:
                # too many args
                raise TypeError
        else:
            loc.update(dict(zip(named_args[:len(args)], args)))
            if f.func_code.co_flags & 4:
                loc[f.func_code.co_varnames[arg_len]] = ()
            for arg in named_args[len(args):]:
                if arg in kwargs:
                    loc[arg] = kwargs[arg]
                else:
                    # not enough args
                    raise TypeError
            for arg in named_args[len(args):]:
                del kwargs[arg]
            if kwargs:
                if f.func_code.co_flags & 8:
                    if f.func_code.co_flags & 4:
                        kwarg_no = arg_len + 1
                    else:
                        kwarg_no = arg_len
                    loc[f.func_code.co_varnames[kwarg_no]] = kwargs
                else:
                    # incorrect kwargs
                    raise TypeError
        print named_args, loc
        return eval(code, f.func_globals, loc)
    
    # XXX should probably try to make "new_f" look as much like "f" as possible
    # XXX we don't currently do this
    return new_f


#class ContextFunctionAdapter(HasTraits):
#    implements(IAdapter)
#
#    # the context factory to generate the local namespace of functions
#    context_factory = Function
#
#    def adapt_setitem(self, context, name, value):
#        """
#        """
#        if isinstance(value, types.FunctionType):
#            return context_function(value, self.context_factory)
#        else:
#            return value
#
#class NameContextFunctionAdapter(HasTraits):
#    implements(IAdapter)
#
#    # the context factory to generate the local namespace of functions
#    function_contexts = Dict
#
#    def adapt_setitem(self, context, name, value):
#        """
#        """
#        if isinstance(value, types.FunctionType) and name in self.function_contexts:
#            return context_function(value, self.function_contexts[name])
#        else:
#            return value
